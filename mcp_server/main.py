# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T10:33:36+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyQuery, BaseSecurity
from fastapi import Path, Query
from pydantic import confloat, conint, constr

from models import (
    AlternativeType,
    CalculateReachableRangePostDataParameters,
    CalculateRoutePostDataParameters,
    ComputeTravelTimeFor,
    ContentType,
    Hilliness,
    InstructionsType,
    Report,
    RouteRepresentation,
    RouteType,
    TravelMode,
    VehicleEngineType,
    VersionNumber,
    Windingness,
)

app = MCPProxy(
    contact={
        'name': 'Contact Us',
        'url': 'https://developer.tomtom.com/contact-us',
        'x-twitter': 'TomTom',
    },
    description='Routing consists of the following service:\n<b>Calculate Route</b>\nCalculates a route between an origin and a destination, passing through waypoints (if specified). Additional routing parameters like traffic, avoidance conditions, departure/arrival time etc. can be taken into account.\n<b>Calculate Reachable Range</b>\nCalculates a set of locations that can be reached from the origin point, subject to the available fuel or energy budget that is specified in the request.',
    title='Routing',
    version='1.0.0',
    servers=[{'url': 'https://api.tomtom.com'}],
)


@app.get(
    '/routing/{versionNumber}/calculateReachableRange/{origin}/{contentType}',
    description=""" Calculates a set of locations that can be reached from the origin point. """,
    tags=['reachable_range_calculation', 'route_planning_operations'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def calculate_reachable_range(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    origin: str = ...,
    content_type: ContentType = Path(..., alias='contentType'),
    fuel_budget_in_liters: Optional[confloat(ge=0.0)] = Query(
        None, alias='fuelBudgetInLiters'
    ),
    energy_budget_ink_wh: Optional[confloat(ge=0.0)] = Query(
        None, alias='energyBudgetInkWh'
    ),
    time_budget_in_sec: Optional[confloat(ge=0.0)] = Query(
        None, alias='timeBudgetInSec'
    ),
    callback: Optional[str] = 'callback',
    report: Optional[Report] = None,
    depart_at: Optional[str] = Query('now', alias='departAt'),
    arrive_at: Optional[str] = Query(None, alias='arriveAt'),
    route_type: Optional[RouteType] = Query('fastest', alias='routeType'),
    traffic: Optional[bool] = True,
    avoid: Optional[str] = None,
    travel_mode: Optional[TravelMode] = Query('car', alias='travelMode'),
    hilliness: Optional[Hilliness] = 'normal',
    windingness: Optional[Windingness] = 'normal',
    vehicle_max_speed: Optional[int] = Query(0, alias='vehicleMaxSpeed'),
    vehicle_weight: Optional[int] = Query(0, alias='vehicleWeight'),
    vehicle_axle_weight: Optional[int] = Query(0, alias='vehicleAxleWeight'),
    vehicle_length: Optional[float] = Query(0, alias='vehicleLength'),
    vehicle_width: Optional[float] = Query(0, alias='vehicleWidth'),
    vehicle_height: Optional[float] = Query(0, alias='vehicleHeight'),
    vehicle_commercial: Optional[bool] = Query(False, alias='vehicleCommercial'),
    vehicle_load_type: Optional[str] = Query(None, alias='vehicleLoadType'),
    constant_speed_consumption_in_liters_per_hundredkm: Optional[
        constr(pattern=r'^((\d+\.?\d*,\d+\.?\d*):?)+$')
    ] = Query(None, alias='constantSpeedConsumptionInLitersPerHundredkm'),
    current_fuel_in_liters: Optional[float] = Query(None, alias='currentFuelInLiters'),
    auxiliary_power_in_liters_per_hour: Optional[float] = Query(
        None, alias='auxiliaryPowerInLitersPerHour'
    ),
    fuel_energy_density_in_m_joules_per_liter: Optional[float] = Query(
        None, alias='fuelEnergyDensityInMJoulesPerLiter'
    ),
    acceleration_efficiency: Optional[float] = Query(
        None, alias='accelerationEfficiency'
    ),
    deceleration_efficiency: Optional[float] = Query(
        None, alias='decelerationEfficiency'
    ),
    uphill_efficiency: Optional[float] = Query(None, alias='uphillEfficiency'),
    downhill_efficiency: Optional[float] = Query(None, alias='downhillEfficiency'),
    vehicle_engine_type: Optional[VehicleEngineType] = Query(
        'combustion', alias='vehicleEngineType'
    ),
    constant_speed_consumption_ink_wh_per_hundredkm: Optional[
        constr(pattern=r'^((\d+\.?\d*,\d+\.?\d*):?)+$')
    ] = Query(None, alias='constantSpeedConsumptionInkWhPerHundredkm'),
):
    """
    Reachable Range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/routing/{versionNumber}/calculateReachableRange/{origin}/{contentType}',
    description=""" Calculates a set of locations that can be reached from the origin point. POST method handles additionally parameters: <em>supportingPoints</em>, <em>allowVignette</em>, <em>avoidVignette</em>, <em>avoidAreas</em>. """,
    tags=['reachable_range_calculation', 'route_planning_operations'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def determine_reachable_range(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    origin: str = ...,
    content_type: ContentType = Path(..., alias='contentType'),
    fuel_budget_in_liters: Optional[confloat(ge=0.0)] = Query(
        None, alias='fuelBudgetInLiters'
    ),
    energy_budget_ink_wh: Optional[confloat(ge=0.0)] = Query(
        None, alias='energyBudgetInkWh'
    ),
    time_budget_in_sec: Optional[confloat(ge=0.0)] = Query(
        None, alias='timeBudgetInSec'
    ),
    callback: Optional[str] = 'callback',
    report: Optional[Report] = None,
    depart_at: Optional[str] = Query('now', alias='departAt'),
    arrive_at: Optional[str] = Query(None, alias='arriveAt'),
    route_type: Optional[RouteType] = Query('fastest', alias='routeType'),
    traffic: Optional[bool] = True,
    avoid: Optional[str] = None,
    travel_mode: Optional[TravelMode] = Query('car', alias='travelMode'),
    hilliness: Optional[Hilliness] = 'normal',
    windingness: Optional[Windingness] = 'normal',
    vehicle_max_speed: Optional[int] = Query(0, alias='vehicleMaxSpeed'),
    vehicle_weight: Optional[int] = Query(0, alias='vehicleWeight'),
    vehicle_axle_weight: Optional[int] = Query(0, alias='vehicleAxleWeight'),
    vehicle_length: Optional[float] = Query(0, alias='vehicleLength'),
    vehicle_width: Optional[float] = Query(0, alias='vehicleWidth'),
    vehicle_height: Optional[float] = Query(0, alias='vehicleHeight'),
    vehicle_commercial: Optional[bool] = Query(False, alias='vehicleCommercial'),
    vehicle_load_type: Optional[str] = Query(None, alias='vehicleLoadType'),
    constant_speed_consumption_in_liters_per_hundredkm: Optional[
        constr(pattern=r'^((\d+\.?\d*,\d+\.?\d*):?)+$')
    ] = Query(None, alias='constantSpeedConsumptionInLitersPerHundredkm'),
    current_fuel_in_liters: Optional[float] = Query(None, alias='currentFuelInLiters'),
    auxiliary_power_in_liters_per_hour: Optional[float] = Query(
        None, alias='auxiliaryPowerInLitersPerHour'
    ),
    fuel_energy_density_in_m_joules_per_liter: Optional[float] = Query(
        None, alias='fuelEnergyDensityInMJoulesPerLiter'
    ),
    acceleration_efficiency: Optional[float] = Query(
        None, alias='accelerationEfficiency'
    ),
    deceleration_efficiency: Optional[float] = Query(
        None, alias='decelerationEfficiency'
    ),
    uphill_efficiency: Optional[float] = Query(None, alias='uphillEfficiency'),
    downhill_efficiency: Optional[float] = Query(None, alias='downhillEfficiency'),
    vehicle_engine_type: Optional[VehicleEngineType] = Query(
        'combustion', alias='vehicleEngineType'
    ),
    constant_speed_consumption_ink_wh_per_hundredkm: Optional[
        constr(pattern=r'^((\d+\.?\d*,\d+\.?\d*):?)+$')
    ] = Query(None, alias='constantSpeedConsumptionInkWhPerHundredkm'),
    body: CalculateReachableRangePostDataParameters = None,
):
    """
    Reachable Range
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/routing/{versionNumber}/calculateRoute/{locations}/{contentType}',
    description=""" Calculates a route between an origin and a destination. """,
    tags=['route_planning_operations', 'reachable_range_calculation'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def calculate_route_info(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    locations: str = ...,
    content_type: ContentType = Path(..., alias='contentType'),
    max_alternatives: Optional[conint(ge=0, le=5)] = Query(0, alias='maxAlternatives'),
    alternative_type: Optional[AlternativeType] = Query(
        'anyRoute', alias='alternativeType'
    ),
    min_deviation_distance: Optional[int] = Query(0, alias='minDeviationDistance'),
    min_deviation_time: Optional[int] = Query(0, alias='minDeviationTime'),
    instructions_type: Optional[InstructionsType] = Query(
        None, alias='instructionsType'
    ),
    language: Optional[str] = 'en-GB',
    compute_best_order: Optional[bool] = Query(False, alias='computeBestOrder'),
    route_representation: Optional[RouteRepresentation] = Query(
        'polyline', alias='routeRepresentation'
    ),
    compute_travel_time_for: Optional[ComputeTravelTimeFor] = Query(
        'none', alias='computeTravelTimeFor'
    ),
    vehicle_heading: Optional[conint(ge=0, le=359)] = Query(
        None, alias='vehicleHeading'
    ),
    section_type: Optional[str] = Query('travelMode', alias='sectionType'),
    callback: Optional[str] = 'callback',
    report: Optional[Report] = None,
    depart_at: Optional[str] = Query('now', alias='departAt'),
    arrive_at: Optional[str] = Query(None, alias='arriveAt'),
    route_type: Optional[RouteType] = Query('fastest', alias='routeType'),
    traffic: Optional[bool] = True,
    avoid: Optional[str] = None,
    travel_mode: Optional[TravelMode] = Query('car', alias='travelMode'),
    hilliness: Optional[Hilliness] = 'normal',
    windingness: Optional[Windingness] = 'normal',
    vehicle_max_speed: Optional[int] = Query(0, alias='vehicleMaxSpeed'),
    vehicle_weight: Optional[int] = Query(0, alias='vehicleWeight'),
    vehicle_axle_weight: Optional[int] = Query(0, alias='vehicleAxleWeight'),
    vehicle_length: Optional[float] = Query(0, alias='vehicleLength'),
    vehicle_width: Optional[float] = Query(0, alias='vehicleWidth'),
    vehicle_height: Optional[float] = Query(0, alias='vehicleHeight'),
    vehicle_commercial: Optional[bool] = Query(False, alias='vehicleCommercial'),
    vehicle_load_type: Optional[str] = Query(None, alias='vehicleLoadType'),
    vehicle_engine_type: Optional[VehicleEngineType] = Query(
        'combustion', alias='vehicleEngineType'
    ),
    constant_speed_consumption_in_liters_per_hundredkm: Optional[
        constr(pattern=r'^((\d+\.?\d*,\d+\.?\d*):?)+$')
    ] = Query(None, alias='constantSpeedConsumptionInLitersPerHundredkm'),
    current_fuel_in_liters: Optional[float] = Query(None, alias='currentFuelInLiters'),
    auxiliary_power_in_liters_per_hour: Optional[float] = Query(
        None, alias='auxiliaryPowerInLitersPerHour'
    ),
    fuel_energy_density_in_m_joules_per_liter: Optional[float] = Query(
        None, alias='fuelEnergyDensityInMJoulesPerLiter'
    ),
    acceleration_efficiency: Optional[float] = Query(
        None, alias='accelerationEfficiency'
    ),
    deceleration_efficiency: Optional[float] = Query(
        None, alias='decelerationEfficiency'
    ),
    uphill_efficiency: Optional[float] = Query(None, alias='uphillEfficiency'),
    downhill_efficiency: Optional[float] = Query(None, alias='downhillEfficiency'),
    constant_speed_consumption_ink_wh_per_hundredkm: Optional[
        constr(pattern=r'^((\d+\.?\d*,\d+\.?\d*):?)+$')
    ] = Query(None, alias='constantSpeedConsumptionInkWhPerHundredkm'),
):
    """
    Calculate Route
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/routing/{versionNumber}/calculateRoute/{locations}/{contentType}',
    description=""" Calculates a route between an origin and a destination. POST method handles additionally parameters: <em>supportingPoints</em>, <em>allowVignette</em>, <em>avoidVignette</em>, <em>avoidAreas</em>. """,
    tags=['route_planning_operations', 'reachable_range_calculation'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def calculate_route_options(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    locations: str = ...,
    content_type: ContentType = Path(..., alias='contentType'),
    max_alternatives: Optional[conint(ge=0, le=5)] = Query(0, alias='maxAlternatives'),
    alternative_type: Optional[AlternativeType] = Query(
        'anyRoute', alias='alternativeType'
    ),
    min_deviation_distance: Optional[int] = Query(0, alias='minDeviationDistance'),
    min_deviation_time: Optional[int] = Query(0, alias='minDeviationTime'),
    instructions_type: Optional[InstructionsType] = Query(
        None, alias='instructionsType'
    ),
    language: Optional[str] = 'en-GB',
    compute_best_order: Optional[bool] = Query(False, alias='computeBestOrder'),
    route_representation: Optional[RouteRepresentation] = Query(
        'polyline', alias='routeRepresentation'
    ),
    compute_travel_time_for: Optional[ComputeTravelTimeFor] = Query(
        'none', alias='computeTravelTimeFor'
    ),
    vehicle_heading: Optional[conint(ge=0, le=359)] = Query(
        None, alias='vehicleHeading'
    ),
    section_type: Optional[str] = Query('travelMode', alias='sectionType'),
    callback: Optional[str] = 'callback',
    report: Optional[Report] = None,
    depart_at: Optional[str] = Query('now', alias='departAt'),
    arrive_at: Optional[str] = Query(None, alias='arriveAt'),
    route_type: Optional[RouteType] = Query('fastest', alias='routeType'),
    traffic: Optional[bool] = True,
    avoid: Optional[str] = None,
    travel_mode: Optional[TravelMode] = Query('car', alias='travelMode'),
    hilliness: Optional[Hilliness] = 'normal',
    windingness: Optional[Windingness] = 'normal',
    vehicle_max_speed: Optional[int] = Query(0, alias='vehicleMaxSpeed'),
    vehicle_weight: Optional[int] = Query(0, alias='vehicleWeight'),
    vehicle_axle_weight: Optional[int] = Query(0, alias='vehicleAxleWeight'),
    vehicle_length: Optional[float] = Query(0, alias='vehicleLength'),
    vehicle_width: Optional[float] = Query(0, alias='vehicleWidth'),
    vehicle_height: Optional[float] = Query(0, alias='vehicleHeight'),
    vehicle_commercial: Optional[bool] = Query(False, alias='vehicleCommercial'),
    vehicle_load_type: Optional[str] = Query(None, alias='vehicleLoadType'),
    vehicle_engine_type: Optional[VehicleEngineType] = Query(
        'combustion', alias='vehicleEngineType'
    ),
    constant_speed_consumption_in_liters_per_hundredkm: Optional[
        constr(pattern=r'^((\d+\.?\d*,\d+\.?\d*):?)+$')
    ] = Query(None, alias='constantSpeedConsumptionInLitersPerHundredkm'),
    current_fuel_in_liters: Optional[float] = Query(None, alias='currentFuelInLiters'),
    auxiliary_power_in_liters_per_hour: Optional[float] = Query(
        None, alias='auxiliaryPowerInLitersPerHour'
    ),
    fuel_energy_density_in_m_joules_per_liter: Optional[float] = Query(
        None, alias='fuelEnergyDensityInMJoulesPerLiter'
    ),
    acceleration_efficiency: Optional[float] = Query(
        None, alias='accelerationEfficiency'
    ),
    deceleration_efficiency: Optional[float] = Query(
        None, alias='decelerationEfficiency'
    ),
    uphill_efficiency: Optional[float] = Query(None, alias='uphillEfficiency'),
    downhill_efficiency: Optional[float] = Query(None, alias='downhillEfficiency'),
    constant_speed_consumption_ink_wh_per_hundredkm: Optional[
        constr(pattern=r'^((\d+\.?\d*,\d+\.?\d*):?)+$')
    ] = Query(None, alias='constantSpeedConsumptionInkWhPerHundredkm'),
    body: CalculateRoutePostDataParameters = None,
):
    """
    Calculate Route
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
